import os
import re
import psycopg2
import logging
from datetime import datetime, timezone
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Ensure logs folder exists
if not os.path.exists("logs"):
    os.makedirs("logs")

# Build a log filename using the current date and time
start_time = datetime.now()
log_filename = f"logs/add_relationships_error_log_{start_time.strftime('%Y%m%d_%H%M%S')}.log"

# Set up logging to record errors to the dynamically named file
logging.basicConfig(
    filename=log_filename,
    level=logging.ERROR,
    format='%(asctime)s:%(levelname)s:%(message)s'
)

# Database connection parameters from environment variables
DB_PARAMS = {
    'dbname': os.getenv('POSTGRES_DB'),
    'user': os.getenv('POSTGRES_USER'),
    'password': os.getenv('POSTGRES_PASSWORD'),
    'host': os.getenv('POSTGRES_HOST', 'localhost'),
    'port': os.getenv('POSTGRES_PORT', '5432')
}

def connect_to_db():
    """Create and return a new database connection."""
    return psycopg2.connect(**DB_PARAMS)

def get_headers(content):
    """
    Returns a list of tuples for each Markdown header found in the content.
    Each tuple contains (header_start_position, header_text).
    """
    headers = []
    header_pattern = re.compile(r'^(#{1,6})\s*(.+)$', re.MULTILINE)
    for match in header_pattern.finditer(content):
        headers.append((match.start(), match.group(2).strip()))
    return headers

def get_section_for_pos(headers, pos):
    """
    Given a list of headers (with their positions) and a position,
    returns the header text of the header immediately preceding that position.
    Defaults to "No Section" if none is found.
    """
    section = "No Section"
    for h_start, h_text in headers:
        if h_start <= pos:
            section = h_text
        else:
            break
    return section

def extract_relationships(content):
    """
    Extract relationships from the note content.
    
    Returns a list of dictionaries with:
      - target_title: cleaned title of the related note.
      - context: snippet (50 characters before and after the link).
      - section: the Markdown header above the link (or "No Section").
      - match_start: position of the link (for internal reference).
    """
    relationships = []
    headers = get_headers(content)
    pattern = re.compile(r'\[\[([^\]]+)\]\]')
    
    for match in pattern.finditer(content):
        raw_link = match.group(1)
        # Remove alias (after '|') and section specifier (after '#')
        cleaned = raw_link.split('|')[0].split('#')[0].strip()
        if not cleaned:
            continue

        # Capture 50 characters before and after the link for context
        start_context = max(0, match.start() - 50)
        end_context = min(len(content), match.end() + 50)
        context_snippet = content[start_context:end_context].replace('\n', ' ').strip()
        
        # Determine section based on the nearest preceding header
        section = get_section_for_pos(headers, match.start())
        
        relationships.append({
            'target_title': cleaned,
            'context': context_snippet,
            'section': section,
            'match_start': match.start()
        })
    return relationships

def get_all_notes(cur):
    """
    Retrieve all notes from local.notes.
    Returns a list of tuples: (id, content, title).
    """
    query = "SELECT id, content, title FROM local.notes"
    cur.execute(query)
    return cur.fetchall()

def get_note_info_by_title(cur, note_title):
    """
    Look up a note in local.notes by title (case-insensitive) and return
    the note's id and title.
    """
    query = "SELECT id, title FROM local.notes WHERE LOWER(title) = LOWER(%s) LIMIT 1"
    cur.execute(query, (note_title,))
    return cur.fetchone()

def insert_relationship(cur, start_node_id, start_node_title, end_node_id, end_node_title, relationship_type, context, section):
    """
    Inserts a relationship record into local.relationships.
    The relationship id is generated by the database using uuid_generate_v4().
    """
    insert_sql = """
    INSERT INTO local.relationships (
        start_node_id, start_node_title, end_node_id, end_node_title,
        relationship_type, context, section, created_at, updated_at
    ) VALUES (
        %s, %s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
    )
    """
    cur.execute(insert_sql, (start_node_id, start_node_title, end_node_id, end_node_title,
                               relationship_type, context, section))

def process_all_notes():
    """
    Process every note in local.notes:
      - Extract relationships from each note's content.
      - For each relationship, look up the target note by title.
      - Insert the relationship into local.relationships.
    Logs errors to the dynamic log file and prints progress to the console.
    """
    conn = connect_to_db()
    cur = conn.cursor()
    total_inserted = 0

    try:
        notes = get_all_notes(cur)
        total_notes = len(notes)
        print(f"Processing {total_notes} notes...")

        for idx, note in enumerate(notes):
            start_node_id, content, start_node_title = note
            print(f"Processing note {idx+1}/{total_notes}: '{start_node_title}'")
            # Skip notes without content
            if not content:
                continue
            try:
                rels = extract_relationships(content)
                if not rels:
                    continue

                for rel in rels:
                    target_title = rel['target_title']
                    context = rel['context']
                    section = rel['section']
                    
                    # Look up target note by title (case-insensitive)
                    target_info = get_note_info_by_title(cur, target_title)
                    if target_info:
                        end_node_id, stored_end_title = target_info
                    else:
                        # If target note is not found, set end_node_id to None and use the extracted title.
                        end_node_id = None
                        stored_end_title = target_title
                    
                    insert_relationship(cur, start_node_id, start_node_title,
                                        end_node_id, stored_end_title,
                                        "default", context, section)
                    total_inserted += 1
                # Commit after processing each note
                conn.commit()
            except Exception as note_error:
                conn.rollback()
                logging.error(f"Error processing note '{start_node_title}' (ID: {start_node_id}): {note_error}")
    except Exception as e:
        logging.error(f"Error retrieving notes: {e}")
    finally:
        cur.close()
        conn.close()

    print(f"Inserted {total_inserted} relationships across all notes.")

def main():
    process_all_notes()

if __name__ == "__main__":
    main()
